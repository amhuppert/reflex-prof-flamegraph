{-# LANGUAGE TupleSections #-}
-- | Parser for .rfprof files generated by Reflex.Profiled.
module ProfFile
  ( EventCount(..)
  , Line(..)
  , lIndividualEventCount
  , lInheritedEventCount
  , parse
  ) where

import           Control.Arrow (second, left)
import           Data.Char (isSpace)
import           Text.Read (readEither)
import           Control.Monad (unless)
import           Control.Applicative
import           Prelude -- Quash AMP related warnings in GHC>=7.10

data EventCount = EventCount
  { eIndividual :: {-# UNPACK #-} !Int
  , eInherited  :: {-# UNPACK #-} !Int
  } deriving (Show, Eq)

data Line = Line
  { lLabel :: String
  -- ^ Format: <Module name>.<Cost Centre Name>
  , lEventCount :: !EventCount
  , lChildren :: [Line]
  } deriving (Show, Eq)

lIndividualEventCount :: Line -> Int
lIndividualEventCount = eIndividual . lEventCount

lInheritedEventCount :: Line -> Int
lInheritedEventCount = eInherited . lEventCount

-- | Returns a function accepting the children and returning a fully
-- formed 'Line'.
parseLine :: String -> Either String ([Line] -> Line)
parseLine s = case words s of
  (label:rest) -> do
    rest' <- dropSRC rest
    case rest' of
      (inhEvents:indEvents:_) ->
        parse' label inhEvents indEvents
      _ -> Left "Unexpected number of fields"
  _ -> Left $ "Malformed .rfprof file line:\n" ++ s
  where
    -- XXX: The SRC field can contain arbitrary characters (from the
    --      subdirectory name)!
    --
    -- Reflex.Profiled currently surrounds the SRC with parentheses, so we drop words until
    -- we see the closing paren.
    --
    -- The implementation is not very efficient, but I suppose this is not
    -- performance-critical.
    dropSRC :: [String] -> Either String [String]
    dropSRC (('(':_):rest) = Right $ go 1 rest
      where
        go 0 ws = ws
        go parenCount (w:ws) =
          let numOpeningParens = length $ filter (== '(') w
              numClosingParens = length $ filter (== ')') w
           in go (parenCount + numOpeningParens - numClosingParens) ws
        go _ [] = []
    dropSRC _ = Left "Expected SRC field to start with '('"

    parse' :: String -> String -> String -> Either String ([Line] -> Line)
    parse' label inhEvents indEvents = do
      lEventCount' <- EventCount <$> readEither' indEvents <*> readEither' inhEvents
      return $ Line label lEventCount'

    readEither' str = left (("Could not parse value "++show str++": ")++)
                           (readEither str)

type LineNumber = Int

processLines :: [String] -> LineNumber -> Either String [Line]
processLines lines0 lineNumber0 = do
  ((ss,_), lines') <- go 0 lines0 lineNumber0
  unless (null ss) $
    error "processLines: the impossible happened, not all strings were consumed."
  return lines'
  where
    go :: Int -> [String] -> LineNumber -> Either String (([String], LineNumber), [Line])
    go _depth [] lineNumber = do
      return (([], lineNumber), [])
    go depth0 (line : lines') lineNumber = do
      let (spaces, rest) = break (not . isSpace) line
      let depth = length spaces
      if depth < depth0
        then return ((line : lines', lineNumber), [])
        else do
          parsedLine <- left (("Parse error in line "++show lineNumber++": ")++) $
                             parseLine rest
          ((lines'', lineNumber''), children) <- go (depth + 1) lines' (lineNumber + 1)
          second (parsedLine children :) <$> go depth lines'' lineNumber''

-- .rfprof files currently have no header and the start of the content is always the first line.
findStart :: [String] -> LineNumber -> Either String ([String], LineNumber)
findStart [] _ = Left "Malformed .rfprof file: couldn't find start line"
findStart lines' lineNumber = Right $ (lines', lineNumber)

parse :: String -> Either String [Line]
parse s = do
  (ss, lineNumber) <- findStart (lines s) 1
  processLines ss lineNumber
